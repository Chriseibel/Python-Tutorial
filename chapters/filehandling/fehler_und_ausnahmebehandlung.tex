% !TeX root = ../../pythonTutorial.tex
\section{Fehler- und Ausnahmebehandlung}
\label{filehandling:section:fehlerundausnahmebehandlung}

In diesem Kapitel beschäftigen wir uns mit der Fehler- und Ausnahmebehandlung in Python.
Dabei sollte darauf geachtet werden, dass überall da, wo ein potenzieller Fehler auftreten kann, die Maßnahmen zur Fehler- und Ausnahmebehandlung angewendet werden.
Somit können wir entsprechende Syntaxfehler zur Laufzeit abfangen und geeignet behandeln, ohne das unser Programm vorzeitig durch einen Absturz beendet wird. 

\subsection{Mögliche Fehlerquellen}
\label{filehandling:section:fehlerquellen}
Die Möglichkeiten der Fehlerquellen sind vielseitig. Eine der Bekanntesten davon ist wohl ein Eingabefehler durch den Benutzer. 
Dieser soll beispielsweise eine Zahl mithilfe der Tastatur eingeben, damit diese durch das Programm weiterverarbeitet werden kann. 
Durch ein Vertippen des Anwenders wird ein Text in Form eines einzelnen Buchstabens anstatt einer Zahl übergeben.
Dies führt zur Laufzeit zu einem Fehler, das Programm hat eine Zahl an Stelle eines Textes erwartet.
Eine andere Fehlerquelle wäre die Division durch die Zahl Null.
Ebenso könnte der Zugriffsversuch auf eine Datei zum Bearbeiten fehlschlagen, da diese zu dem aktuellen Zeitpunkt noch nicht existiert.
\\ \\
Aus diesen genannten Ursachen ist eine Fehler- und Ausnahmebehandlung sinnvoll und sollte von einem Programmierer für einen möglichen Einsatz stets bedacht werden.

\subsection{try, except, else und finally}
\label{filehandling:section:tryblock}


Der \lstinline$try-Block$  \randnotiz{try}wird mit dem Schlüsselwort \lstinline$try$ gefolgt von einem Doppelpunkt eingeleitet. 
Anschließend wird der auszuführende Code, der einen Fehler beinhalten könnte, darin angegeben.
Mit dem Schlüsselwort\randnotiz{except} \lstinline$except$   und dem Namen der zu behandelnden Fehlerklasse wie beispielsweise \\ \lstinline$ZeroDivisionError$ kann ein entsprechender Fehler geeignet behandelt werden. 
Dabei sind auch mehrere \lstinline$except$-Anweisungen mit unterschiedlichen Fehlerklassen möglich, um eine entsprechende Behandlung zu ermöglichen. 
Somit kann jeder Fehler nach seiner eigenen Art und Weise nach dem Auftreten konsequent und individuell behandelt werden. 
% Somit kann jdeder Fehler entsprechend individuell behandelt werden.
Auch die Erstellung von eigenen Fehlerklassen ist in Python möglich, dazu später mehr.
\\ \\
Einige wichtige und gängige Fehlerklassen sind hierbei: 
\\ \\
\lstinline$"ZeroDivisonError"$: Tritt auf bei einer Division durch die Zahl null.

\lstinline$"FileNotFoundError"$: Tritt auf, wenn die zu öffnende Datei nicht gefunden werden kann.

\lstinline$"IOError"$: Tritt auf, wenn man auf eine Ressource zugreifen möchte, die momentan nicht verfügbar ist. Beispielsweise der Zugriff auf einen Drucker, der zu dem aktuellen Zeitpunkt sich in dem Status \glqq{}offline\grqq{} befindet.

\lstinline$"ValueError"$: Tritt auf, wenn ein anderer Datentyp als der erwartete Verarbeiteten werden soll. 
Beispiel: Es wird eine Zahl erwartet, aber ein Text übergeben.

Darüber hinaus gibt es noch weitere wie z. B. ImportError, KeyError, MemoryError, NameError, TypeError und viele mehr, die hier im Kontext nicht weiter erläutert werden.

Im folgenden Listing wird ein Fehler provoziert, indem wir eine Division mit der Zahl Null herbeiführen. 
Hierbei wird die Fehlerbehandlung mit der Klasse \lstinline$ZeroDivisonError$ abgefangen und anschließend das Programm durch die Fehlerbehandlung ordnungsgemäß beendet. 
Dabei wird die nachfolgende \lstinline$else-klausel$ durch das Auftreten und Abfangen des Fehlers nicht ausgeführt.

\lstinputlisting[language=Python,
 firstline=1,lastline=16]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:zerodivisonerror}

Die \lstinline$else$-Anweisung \randnotiz{else}kann im Code optional mit angegeben werden und wird nur ausgeführt, 
falls es zu keiner Ausnahme in dem \lstinline$try-Block$ kommt.
Somit wird nach der Ausführung des \lstinline$try-Blocks$ auch der in \lstinline$else$ stehende Code ausgeführt, wie es das nachfolgende Listing demonstriert:

\lstinputlisting[language=Python, linerange={1-3,20-32}]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:else}


Mit der ebenfalls optionalen Angabe von \lstinline$finally$ \randnotiz{finally} lässt sich ein Codestück unter allen Umständen, ausführen. 
Somit wird gewährleistet das dieser Teil des Codes ungeachtet, ob eine Ausnahme eintrifft oder nicht garantiert durchlaufen wird. 
Dies kann vor allem bei dem Schließen einer Datei oder einer Datenbankverbindung sehr sinnvoll eingesetzt werden.

Bei dem folgenden Listing wird eine Datei zunächst angelegt und geöffnet. 
Anschließend wird das Ergebnis in die Datei geschrieben. 
Ungeachtet dessen ob im \lstinline$try-Block$ eine Fehlerbehandlung eintritt oder nicht, wird zum Schluss garantiert die \lstinline$finally$-Anweisung durchlaufen. 
Damit ist die Schließung der Datei garantiert.

\lstinputlisting[language=Python, linerange={1-3,36-58}]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:finally}

Anstatt die beiden Fehlerklassen \lstinline$ZeroDivisonError$ und \lstinline$FileNotFoundError$ mit demselben Code individuell zu behandeln, 
bietet es sich hier an, mehrere Ausnahmen innerhalb eines \lstinline$except$ zusammenzufassen. 
Tritt nun während der Abarbeitung im \lstinline$try-Block$ einer der genannten Fehler auf, wird die Fehlerbehandlung ausgeführt.

\begin{lstlisting}[language=Python]
except (ZeroDivisionError, FileNotFoundError) as e:
	print("error message: ", e)
	print("Das Programm wird beendet.")
\end{lstlisting}

\section {raise}
\label{filehandling:sec:raise}

Die \lstinline$raise$-Anweisung ermöglicht uns das Generieren bzw. Auslösen einer Ausnahme. Dabei wird die Ausnahme angegeben, die ausgelöst werden soll. 

\lstinputlisting[language=Python, linerange={1-3,61-70}]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:raise}

Somit ist es uns beispielsweise möglich eine \lstinline$ZeroDivisonError$ zu erzwingen, wie das folgende Beispiel demonstriert:

\lstinputlisting[language=Python, linerange={1-3,73-81}]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:raisemitaufruf}

\section {Selbst definierte Ausnahmen}
\label{filehandling:sec:selbstdefinierteeausnahmen}

Nachdem wir uns mit der \lstinline$raise$-Anweisung beschäftigt haben, widmen wir uns den selbst definierten Ausnahmen. 
Diese werden in der Regel als eigenen Klassen definiert und müssen dabei von der Oberklasse \lstinline$Exception$ erben.
Das nachfolgende Listing zeigt ein entsprechendes Szenario. 
Dabei wird zunächst eine eigene Klasse \lstinline$MyException$ definiert, die von Exception erbt. 
Durch die \lstinline$raise$-Anweisung können wir unsere selbst definierte Ausnahme auslösen.

\lstinputlisting[language=Python, linerange={1-3,85-97}]{chapters/filehandling/src/fehler_und_ausnahmebehandlung/ExceptionHandling.py}
\label{filehandling:lst:eigeneaushamendefiniert}
