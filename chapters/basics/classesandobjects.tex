% !TeX root = ../../pythonTutorial.tex

\section{Klassen und Objekte}

Python ist wie Java eine Objektorientierte Programmiersprache. 
Das bedeutet, dass in Python fast alles aus Objekten und Klassen besteht.
Klassen sind Vorlagen, aus denen Objekte generiert werden können.
Dabei enthält die Klasse je nach Verwendungszweck Variablen und Funktionen.
Ein klassisches Beispiel wäre die Klasse \glqq Schüler\grqq{}. Jeder Schüler hat einen Namen, aber nicht jeder Schüler hat den gleichen Namen.

\subsection{Klassen und Objekte erstellen}

Um dies  Anhand eines Python Programms zu verdeutlichen wird eine neue Klasse erstellt.
\begin{lstlisting}[language=Python, label=classesandobjects:subsection:createclassesandobjects]
# Erstellen einer Klasse
class Schueler:
name = "Name einfuegen"
\end{lstlisting}
Mithilfe der erstellten Klasse, kann man nun verschiedene Objekte erstellen, welche die Variablen und Funktionen der Klasse enthalten.
\begin{lstlisting}[language=Python, label=classesandobjects:subsection:createclassesandobjects]
class Schueler:
name = "Name einfuegen"
schueler1 = Schueler()
print(schueler1.name)
\end{lstlisting}
Ausgabe des Programmcodes:
\begin{lstlisting}[language=Python, label=classesandobjects:subsection:createclassesandobjects]
# Output der Konsole
Name einfuegen
\end{lstlisting}
Die Variablen der Objekte sind zunächst gleich mit denen der Klasse, aus der diese erstellt wurden.
Allerdings sind die Variablen des erstellten Objekts unabhängig von denen der Klasse. Das bedeutet, dass  man diese auch unabhängig für jedes einzelne Objekt ändern kann. Die im obigen Beispiel verwendete Klasse ist in realen Anwendungen  nicht verwendbar, da die Attribute des Objekts von Anfang an festgelegt wurden. Um einen dynamischen Ansatz zu nutzen, sollte man wie im nächsten Beispiel vorgehen.
\begin{lstlisting}
class Schueler:
def __init__(self, name):
self.name = name

schueler1 = Schueler("Patrick")
schueler2 = Schueler("Sebastian")
print(schueler1.name)
print(schueler2.name)
\end{lstlisting}
Ausgabe des Programmcodes:
\begin{lstlisting}
Patrick
Sebastian
\end{lstlisting}

\subsection{Die init() Funktion}
Jede Klasse hat eine init() Funktion, die immer ausgeführt wird, wenn die Klasse initiiert und ausgeführt wird. Diese Funktion wird verwendet um den Variablen des Objektes einen Wert zu geben.
Hierbei ist der self Parameter notwendig um die Klasse selbst zu referenzieren und um auf die Variablen der Klasse zugreifen zu können. Dieser Parameter ist also notwendig, muss aber nicht self genannt werden, sondern kann einen beliebigen Namen haben. Er wird als erster Parameter bei jeder Funktion angegeben.
\begin{lstlisting}
class Schueler:
def __init__(self, name):
self.name = name

def getName(self):
print(self.name)

schueler1 = Schueler("Patrick")
schueler2 = Schueler("Sebastian")
schueler1.getName()
schueler2.getname()
\end{lstlisting}
Ausgabe des Programmcodes: 
\begin{lstlisting}
Patrick
Sebastian
\end{lstlisting}

Objekte enthalten die aus den Klassen übernommenen Funktionen. Diese Funktionen gehören jetzt dem Objekt und werden Methoden genannt.
Um Parameter zu modifizieren oder zu löschen, können einfach die Befehle.
objektname.parameter = neuer Wert (modifizieren) und del objektname.parameter (löschen) verwendet werden.
\begin{lstlisting}
class Schueler:
def __init__(self, name):
self.name = name

def getName(self):
print(self.name)

schueler1 = Schueler("Patrick")
schueler2 = Schueler("Sebastian")
schueler1.name = "Lukas"
schueler1.getName()
schueler2.getname()
del schueler2.name
\end{lstlisting}
Ausgabe des Programmcodes: 
\begin{lstlisting}
Lukas
Sebastian
\end{lstlisting}

\subsection{Vererbung}

Ein weiterer wichtiger Aspekt der Klassen in Python ist die Vererbung und Erg{\"a}nzung einer Klasse.
\begin{lstlisting}
class Schueler:
def __init__(self, name):
self.name = name

def getName(self):
print(self.name)

class Hochschule:
def __init__(self, name, matrikelnummer):
Schueler..__init__(self, name)
self.matrikelnummer = matrikelnummer

def getName(self):
print(Schueler.getName(self) + ", " + self.matrikelnummer)

schueler1 = Hochschule("Patrik","1234")
schueler2 = Hochschule("Sebastian", "1235")
schueler1.getName()
schueler2.getname()
\end{lstlisting}
Ausgabe des Programmcodes: 
\begin{lstlisting}
Patrick, 1234
Sebastian, 1235
\end{lstlisting}
In diesem Beispiel wurde die Klasse Sch{\"u}ler durch die Klasse Hochschule erweitert. Dies geschieht durch das Hinzuf{\"u}gen eines weiteren Attributes (bspw. Matrikelnummer). Dieses Attribut hat dann die Funktion getName abge{\"a}ndert. Die Klasse, von der geerbt wird, kann man entweder mit dem Klassennamen (Schueler) oder mit super referenzieren. Trotz der {\"A}nderung der Funktion getName in der Klasse Hochschule, beh{\"a}lt die Klasse Sch{\"u}ler ihre Funktion.

Zum Schluss bleibt zu erw{\"a}hnen, dass auch komplette Objekte l{\"o}schbar sind. Dies ist mit dem Befehl del objektname m{\"o}glich. Hierbei wird eine Fehlermeldung ausgegeben, da versucht wird, auf das gel{\"o}schte Objekt zuzugreifen.
\begin{lstlisting}
class Schueler:
def __init__(self, name):
self.name = name

def getName(self):
print(self.name)

schueler1 = Schueler("Patrick")
schueler2 = Schueler("Sebastian")
schueler1.name = "Lukas"
schueler1.getName()
schueler2.getname()
del schueler2.name
del schueler2
schueler2.getName()
\end{lstlisting}
Fehlermeldung beim Ausf{\"u}hren des Programmcodes:
\begin{lstlisting}
Traceback (most recent call last):
Lukas
File"C:/users/Patrick/Desktop/python/objekte
_undklassen.py", line 15, in <module>
Sebastian
schueler2.getName()
NameError: name 'schueler2' is not defined 
\end{lstlisting}