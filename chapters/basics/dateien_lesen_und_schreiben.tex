% !TeX root = ../../pythonTutorial.tex
\section{Dateien lesen und schreiben}
\label{filehandling:section:dateienlesenundschreiben}
\randnotiz{Dateien lesen und schreiben}
Python bietet nativ Möglichkeiten für das Bearbeiten von Dateien. Hierfür werden Objekte erstellt und verwendet, die eine Datei im Quellcode repräsentieren. Mit Hilfe dieser, im folgenden \lstinline$fileObjects$ genannt, lässt sich der Inhalt einer Datei ändern und wird gespeichert, sobald es im Code geschlossen wird.

\subsection{Dateitypen}
\label{filehandling:section:filetypes}
\randnotiz{Dateitypen}
In Python werden Dateien in zwei Kategorien eingeteilt. Entweder Text- oder Binärdateien.

Textdateien bestehen aus Zeilen, welche aus einer Zeichensequenz bestehen und mit einem "End of Line"-Zeichen beendet werden. Als solches kann beispielsweise ein Zeilenumbruch oder Komma dienen. 

Als Binärdateien werden sämtliche Dateien interpretiert, die keine Textdateien sind.Um diese nutzen zu können, muss der Programmierer eine Möglichkeit zur Verarbeitung bereitstellen. 

In diesem Kapitel wird ein durchgängiges Beispiel anhand einer Textdatei durchgeführt. 

\subsection{Open-Methode}
\label{filehandling:section:open}
\randnotiz{open()}
Die tragenden Rolle für das Bearbeiten von Dateien in Python ist die \lstinline$open()$-Methode. Diese erlaubt das Erstellen, Öffnen, Aktualisieren, Lesen und Schreiben einer Datei.

Mit Hilfe des folgenden Codes wird eine neue Datei erstellt und als \lstinline$fileObject$ geöffnet.
\lstinputlisting[language=Python, firstline=1,lastline=4]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:open}
Zum Erstellen einer neuen Datei, wird ein Dateiname und als zweiten Parameter der \lstinline$"x"$-Modus gewählt. Die Datei wird am selben Speicherort, wie die .py-Datei erzeugt, sofern vor dem Dateinamen kein Pfad angegeben wird. Sollte an der angegebenen Stelle bereits eine Datei mit dem gewählten Namen existieren, bleibt diese unverändert und es wird ein Fehler erzeugt. 

Wird das \lstinline$fileObject$ im Code nicht mehr benötigt, wird es mit folgender Zeile geschlossen.
\lstinputlisting[language=Python, linerange={1-3,5-5}]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:close}
Somit wird die Datei geschlossen und der verwendete Speicherplatz freigegeben, das Arbeiten an dieser ist dann über das entsprechende \lstinline$fileObject$ nicht mehr möglich. 

\tip{Es empfiehlt sich direkt im Anschluss an die Verwendung der \lstinline$open()$ die Datei an anderer Stelle zu schließen. Auf diese Weise wird sichergestellt, dass die Datei nicht unabsichtlich bearbeitet wird.}

Für die \lstinline$open()$ stehen folgende Modi \randnotiz{Zugriffmodus} zur Verfügung:

\lstinline$"x"$: Erzeugen einer neuen Datei. Sollte bereits eine Datei mit dem gewählten Namen existieren, wird ein Fehler ausgegeben.

\lstinline$"r"$: Lesen einer Datei.

\lstinline$"r+"$: Lese- und Schreibrechte auf einer Datei.

\lstinline$"a"$: Hinzufügen von Inhalt am Ende der Datei. Erzeugt eine neue Datei, sofern keinem mit dem gewählten Namen an angegebener Stelle existiert.

\lstinline$"a+"$: \lstinline$"a"$ wird um das Leserecht auf der Datei ergänzt.

\lstinline$"w"$: Schreiben einer Datei. Überschreibt den Inhalt der Datei. Sollte die Datei mit dem gewählten Namen noch nicht existieren, wird eine neue erzeugt.

\lstinline$"w+"$: \lstinline$"w"$ wird um das Leserecht auf der Datei ergänzt.

\lstinline$"t","b"$: Angabe, ob die Datei als Text- \lstinline$"t"$ oder Binärdatei \lstinline$"b"$ interpretiert wird. Diese Modi können jeweils zu den anderen hinzugefügt werden. Standardmäßig wird die Datei als Text interpretiert, \lstinline$"t"$ kann hierbei weggelassen werden.
\lstinputlisting[language=Python, firstline=1,lastline=9]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandling.py}
\label{filehandling:lst:opentype}


\subsection{Methoden}
\label{filehandling:section:methods}
\randnotiz{Methoden}
Die zuvor erstellte Datei hat noch keinen Inhalt. Um dies zu ändern, wird die \lstinline$datei.txt$ im \lstinline$"w"$-Modus geöffnet. Danach kann der Datei über die \lstinline$write()$-Methode wie folgt eine Textzeile hinzugefügt werden.
\lstinputlisting[language=Python, firstline=7,lastline=12]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwrite}
Mit Hilfe der \lstinline$writelines()$-Methode kann die Datei mit einer List von String-Werten beschrieben werden.
\lstinputlisting[language=Python, firstline=14,lastline=22]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwritelines}
Die Datei in dem Beispiel wurde erstellt, geöffnet, beschrieben und überschrieben. Als nächstes soll der Inhalt aus der Datei auf der Konsole ausgegeben werden. Hierzu wird der Modus, in dem die \lstinline$datei.txt$ geöffnet wird, auf \lstinline$"r"$ gestellt. Die \lstinline$read()$-Methode liefert den Inhalt als String, welcher über \lstinline$print()$ ausgegeben wird.
\lstinputlisting[language=Python, firstline=24,lastline=34]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openread}
Soll eine einzelne Zeile ausgegeben werden, kann die \lstinline$readline()$-Methode verwendet werden. Mittels eines int-Werts als Parameter kann eine Grenze festgelegt werden, welche bestimmt, bis zu welcher Position die Zeile ausgelesen werden soll. Ohne Angabe eines Parameters wird die gesamte Zeile ausgelesen. Dies gilt sowohl für die \lstinline$read()$- als auch für die \lstinline$readline()$-Methode.

%# Übungsaufgabe
%Führen Sie folgenden Code aus. Was fällt Ihnen auf?
%#Code
%fileObject = open("datei.txt", "r")
%print(fileObject.readline())
%print(fileObject.readline())
%print(fileObject.readline())
%fileObject.close()
%
%# Ausgabe
%Hallo Welt.
%
%Das ist ein
%
%Beispieltext
%
%Antwort: Die datei.txt besitzt drei Zeilen Inhalt und es wird für jede Zeile die Anweisung \lstinline$print(fileObject.readline())$ benötigt,
%um den Inhalt vollständig auszugeben.
%Folglich muss im \lstinline$fileObject$ die aktuelle Leseposition gespeichert sein.

Wie die vorangegangene Aufgabe gezeigt hat, besitzt ein \lstinline$fileObject$ einen Zeiger, welcher auf die aktuelle Position in der Datei zeigt. Dazu später mehr.		

Anstelle der Ausgabe über \lstinline$read()$ oder der mehrfachen Verwendung von \lstinline$readline()$, können wir auch über das \lstinline$fileObject$ iterieren. In diesem Fall verwenden wir eine for-Schleife.
\lstinputlisting[language=Python, firstline=36,lastline=49]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openreadfor}
Eine weitere Alternative ist die \lstinline$readlines()$-Methode, die eine List mit den Zeilen der Datei als Inhalt liefert.
\lstinputlisting[language=Python, firstline=51,lastline=58]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openreadlines}
Wird die \lstinline$readlines()$-Methode zweimal hintereinander verwendet, erhalten wir folgende Ausgabe.
\begin{lstlisting}[language=Python]
# Ausgabe:

['Hallo Welt.\n', 'Das ist ein\n', 'Beispieltext']
[]
\end{lstlisting}
Nach dem ersten Aufruf der Methode befindet sich der Zeiger am Ende des \lstinline$fileObject$, somit kann bei dem zweiten Aufruf kein Inhalt mehr ausgelesen werden. Mit Hilfe der \lstinline$tell()$-Methode kann die aktuelle Position des Zeigers ausgegeben werden. Fügen wir den folgenden Code vor den \lstinline$readlines()$-Methoden ein, kann der Zeiger verfolgt werden.
\lstinputlisting[language=Python, firstline=60,lastline=74]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:opentell}
Soll die Ausgabe beider Lists identisch sein, muss der Zeiger an den Anfang zurückgesetzt werden. In Python existiert für diesen Zweck die \lstinline$seek()$-Methode. Wird der Zeiger direkt nach der ersten Verwendung der \lstinline$readlines()$-Methode auf die Position \lstinline$0$ zurückgesetzt, erhalten wir die gewünschte Ausgabe.
\lstinputlisting[language=Python, linerange={75-77,81-81, 85-90}]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openseek}

\subsection{With-Statement}
\label{filehandling:section:withstatement}
\randnotiz{With-Statement}
Bisher mussten wir in dem Code-Beispiel die \lstinline$open()$-Methode verwenden und darauf achten, dass das \lstinline$fileObject$ mit \lstinline$close()$ nach Gebrauch wieder geschlossen wird.

Alternativ kann das \lstinline$with$-Statement genutzt werden. So wird die Datei nach Verwendung automatisch geschlossen, ohne explizite Angabe von \lstinline$close()$. Der Code zum Auslesen der datei.txt lautet wie folgt aus.
\lstinputlisting[language=Python, firstline=92,lastline=101]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwithstatement}

\subsection{Attribute}
\label{filehandling:section:attributes}
\randnotiz{Attribute}
Jedes \lstinline$fileObject$ besitzt Attribute, welche Auskunft über das Objekt geben.
\begin{description}
	\item[closed:] Gibt Auskunft darüber, ob die Datei geschlossen wurden. Liefert einen boolean-Wert.
	\item[mode:] Liefert den Zugriffsmodus auf die Datei als String.
	\item[name:] Liefert den Namen der geöffneten Datei als String.
\end{description}

\lstinputlisting[language=Python, firstline=0,lastline=12]{chapters/basics/src/dateien_lesen_und_schreiben/FileHandlingAttributes.py}
\label{filehandling:lst:openattributes}