% !TeX root = ../../pythonTutorial.tex
\section{Testing}
\label{tests:sec:Testing}
Zum Testen unter Python gibt es mehrere Module die das Testen unterstützen.
Zum einen das Modul \lstinline$doctest$, welches als interaktive Dokumentation Testmuster bereitstellt.
Zum anderen das Modul \lstinline$unittest$, welches den Unittests unter Java mit JUnit sehr ähnelt.
Beide Module ermöglichen Regressionstesten.
\subsection{doctest}
\label{tests:sec:DocTest}
Das Modul \lstinline$doctest$ ermöglicht es Tests parallel mit dem Programmcode in die selbe Datei zu schreiben.
Dies ist sowohl innerhalb von Funktionen als auch außerhalb möglich.
Hierbei werden die Tests in Kommentarblöcken (\lstinline$"""$) durch die Zeichenfolge \lstinline$>>>$ eingeleitet.
Danach wird die Funktion, die getestet werden soll mit den gewünschten Testparametern aufgerufen.
Diesem folgt dann entweder das Ergebnis oder eine Fehlerbehandlung im Falle einer zu prüfenden Exception.

\lstinputlisting[language=Python,lastline=37, label={tests:lst:SimpleDocTest}]{chapters/basics/src/tests/simpleDocTest.py}

Beispiel \ref{tests:lst:SimpleDocTest} zeigt, wie \lstinline$doctests$ in der Praxis Anwendung finden.
Die Tests werden, sobald der Code ausgeführt wird ebenfalls ausgeführt. 
Dadurch das die Tests nach bei dem zu testenden Code stehen wird ein direkter Bezug zwischen beiden hergestellt.
Sollte beim Ausführen kein Test Fehlschlagen, kommt es zu keiner Ausgabe durch den Interpreter.
Ist trotzdem eine Ausgabe erwünscht, ist diese mit dem Parameter \lstinline$-v$ (verbose) aktivierbar.

Im nachfolgenden Beispiel \ref{tests:lst:SimpleDocTestPrintSuccess} ist die Ausgabe der Tests aus dem oben gezeigten Codebeispiel \ref{tests:lst:SimpleDocTest}, zu sehen.
Der Ablauf, der einzelnen Test, ist jedes Mal gleich.
Zuerst wird der Test, mit den Versuchsparametern ausgegeben und im Anschluss der Erwartungswert gezeigt.
Sollte der Rückgabewert der Funktion dem Erwartungswert entsprechen, wird der Test mit OK beendet.
Gleiches gilt beim Testen auf Exceptions.
Zum Schluss werden die Ergebnisse in einer Auflistung zusammengefasst und nach Zugehörigkeit gruppiert.
Hierbei handelt es sich um einen freien Test und 3 innerhalb der Funktion.
Danach gibt es noch eine weitere Zusammenfassung, die die Tests nach Erfolg und Misserfolg gruppiert.
Dies soll dem Anwender ermöglichen, alle Tests mit einem Blick zu erfassen.

\lstinputlisting[language=python,linerange={1-3,40-69}, label={tests:lst:SimpleDocTestPrintSuccess}]{chapters/basics/src/tests/simpleDocTest.py}

Um auch denn Fehlerfall zu betrachten, wurde die Rückgabe der Funktion von \lstinline$x*y$ auf \lstinline$x+y$ geändert.
Dies sorgte sofort für zwei Fehler beim Start des Programms.
Die einzelnen Fehler werden getrennt dargestellt.
Im Unterschied zum Erfolgsfall wird hier die Stelle angegeben, an der der Test steht.
Zusätzlich dazu wird der zurückgegebene Wert angezeigt.
Am Ende erfolgt wieder eine Zusammenfassung.

\lstinputlisting[language=python,linerange={1-3,73-93}, label={tests:lst:SimpleDocTestPrintFailure}]{chapters/basics/src/tests/simpleDocTest.py}




\subsection{unittest}
\label{tests:sec:UnitTest}
Zum Testen unter Python gibt es ein eigenes Modul.
Dieses wurde in Anlehnung an JUnit aus Java erstellt.
Ziel ist es, dem Programmierer zu ermöglichen kleine wiederholbare Tests zu schreiben.
Mit diesen Testfällen lässt sich Programmcode auf Integrations- und Operationsebene testen.


\subsubsection*{Beispieltest}
\label{tests:sec:BeispielTest}

Zum Einstieg in das Thema Unittest, zunächst ein kleines Beispiel einer Testklasse.
\lstinputlisting[language=Python, label={tests:lst:BeispielTest}]{chapters/basics/src/tests/simpleTest.py}

Um einen Test zu erstellen, muss die Klasse, in der die Testfälle definiert werden, von \lstinline$unittest.TestCase$ ableiten.
Hierfür muss zuvor das Testframework \lstinline$unittest$ importiert werden.
Anschließend können die einzelnen Testmethoden einleitend mit der Bezeichnung \textit{test} definiert werden.
Die einzelnen Testfälle werden parallel und ohne Reihenfolge abgearbeitet.
Zusätzlich zu den einzelnen Testfällen existieren noch zwei weitere Methoden zu Ablaufsteuerung.
Die Methode \lstinline$setUp()$ sowie die Methode \lstinline$tearDown()$.
Diese beide Methoden erlauben das Ausführen von Code vor und nach jeder einzelnen Testmethode.
Dies ermöglicht es bestimmte Testvoraussetzungen vor jedem Test schaffen.


\subsubsection*{Ausführen von Testzusammenstellungen}
\label{tests:sec:AusfuehrenVonTestzusammenstellungen}
Die erstellten Tests können nicht so ohne Weiteres auf der Konsole ausgeführt werden.
Um das Testen zu starten, ist es notwendig Python über den Parameter \lstinline$-m unittest$ aufzurufen.
Dies ist erforderlich um das Modul Unittest im Skriptmodus zu starten.
Im Anschluss folgt das zu testende Subjekt.
Dieses kann entweder mehrere Module, eine Klasse oder eine einzelne Methode sein.
Die Pythondatei selbst ist ebenfalls ein mögliches Testsubjekt sein.
Hierbei werden natürlich nur die Testfälle in der Datei ausgeführt.

\begin{lstlisting}[label=tests:lst:AusfuehrenVonTestzusammenstellungen,language=bash]
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method
python -m unittest tests/test_something.py
\end{lstlisting}

Empfehlenswert ist des Weiteren noch der Parameter \lstinline$-v$ da dieser dafür sorgt, dass die erfüllten Tests angezeigt werden.
Weitere Parameter hierzu können der Python Dokumentation \cite{pythondoku}.
Alternativ kann durch den Parameter \lstinline{-h} eine Liste der Parameter auf der Konsole ausgegeben werden.

\subsubsection*{Test Discovery}
Das Modul Unittest bietet seit Python 3.2 eine 

